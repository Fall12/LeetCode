#leetcode 136、137

[136 只出现一次的数](https://leetcode-cn.com/problems/single-number/)
[137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

**位运算相关**
### 解决思路
##### 136 只出现一次的数
直接用^ 运行即可解决。
##### 137 只出现一次的数字 II
只有一个数出现一次，其他的数都是出现3次，int按32位算，可以对每位进行累计，并对3取余。  

例如有数组[1,1,1,2]
> 0 1   
> 0 1  
> 0 1  
> 1 0  
> ---累计取余后  
> 1 0   

**注意：**由于负数的存在，计算机是按补码进行计算的，可以在计算的时候，都先转成整数，然后计算负数的个数，也是按3取余。

	  func singleNumber(nums []int) int {
		res := 0
	
		for i:= 0; i< 32;i++ {
			mark := 0
			value := 1<< uint(i)
			for _, v := range nums {
				if v < 0 {
					v *= -1
				}
				if (v&value) != 0 {
					mark += 1
				}
			}
			if mark% 3 != 0 {
				res |= value
			}
		}
	
		flag := 0
		for _, v := range nums {
			if v < 0  {
				flag += 1
			}
		}
	
		flag %= 3
		if flag > 0 {
			res *= -1
		}
		return res
	}
	
###拓展

有一个 n 个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为 O(n) 且再开辟的内存空间固定(与 n 无关)。

示例 :
输入: [1,2,2,1,3,4]    
输出: [3,4]

#####解决思路

按照136的^位运算，可以得到7，说明两位不同的数在111这三位都不同。

那么，随便取最右这位，将数组分为两组，一组该位为1的[1,1,3]，另一组该位为0的[2,2,4]。然后再用136题的算法解决剩下的问题。

